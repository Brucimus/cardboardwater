<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Worldvision Clean Water Project</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        margin: 0px;
        overflow: hidden;
      }
      #webglviewer {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
      }
    </style>
  </head>
  <body>
    <div id="webglviewer"></div>

  <script src="js/third-party/threejs/three.js"></script>
  <script src="js/third-party/threejs/StereoEffect.js"></script>
  <script src="js/third-party/threejs/DeviceOrientationControls.js"></script>
  <script src="js/third-party/threejs/OrbitControls.js"></script>

  <script>
    var camera, scene, renderer;
    var effect, controls;
    var element, container;

    var clock = new THREE.Clock();

    init();
    animate();

    function init() {
      renderer = new THREE.WebGLRenderer();
      element = renderer.domElement;
      container = document.getElementById('webglviewer');
      container.appendChild(element);

      effect = new THREE.StereoEffect(renderer);

      scene = new THREE.Scene();

      camera = new THREE.PerspectiveCamera(90, 1, 0.001, 700);
      camera.position.set(0, 10, 0);
      scene.add(camera);

      controls = new THREE.OrbitControls(camera, element);
      controls.rotateUp(Math.PI / 4);
      controls.target.set(
        camera.position.x + 0.1,
        camera.position.y,
        camera.position.z
      );
      controls.noZoom = true;
      controls.noPan = true;

      function pointer(e, t) {
        function r(e) {
        e.touches ? (0 == e.touches.length ? (e.x = 0, e.y = 0) : (e.x = e.touches[0].clientX, e.y = e.touches[0].clientY), e.button = 0) : (e.x = e.clientX, e.y = e.clientY)
        }

        function n(t) {
        return function(n) {
            var i = e.getBoundingClientRect();
            r(n), n.localX = n.x - i.left, n.localY = n.y - i.top, t(n)
          }
        }

        function i(t, r, n, i) {
        return i = i || e, i.addEventListener(t, r, !1),
            function() {
                i.removeEventListener(t, r, !1)
            }
          }

          function o(t, n, o) {
          function a(e) {
            r(e), "dragend" == t && n.call(this, e), f(), d()
            }
            var s, l, c, h, f, d, p, m;
              i(u ? "touchstart" : "mousedown", function(g) {
                return r(g), m = e.getBoundingClientRect(), g.preventDefault(), g.stopPropagation(), c = s = g.x, h = l = g.y, p = !1, f = i(u ? "touchmove" : "mousemove", function(e) {
                r(e), e.localX = e.x - m.left, e.localY = e.y - m.top, e.movementX = e.x - s, e.movementY = e.y - l, e.deltaX = e.x - c, e.deltaY = e.y - h, e.px = s, e.py = l, s = e.x, l = e.y, p || (p = !0, "dragstart" == t && n.call(this, e)), "drag" == t && n.call(this, e)
                }, o, window), d = i(u ? "touchend" : "mouseup", a, o, window), !1
              })
            }

          function a(e, n, o) {
            function a() {
            clearTimeout(v), f && f(), d && d()
            }

            function s(r) {
            "tap" == e && l() - g < t.holdDuration && n.call(this, r), a()
          }

          function h(e) {
            r(e), c(e.x, e.y, p, m) > t.tapMoveThreshold && a()
          }
          var f, d, p, m, g, v;
            a(), i(u ? "touchstart" : "mousedown", function(a) {
            r(a), g = Date.now(), p = a.x, m = a.y, "hold" == e && (v = setTimeout(function() {
                n.call(o, a)
            }, t.holdDuration)), f = i(u ? "touchend" : "mouseup", s, o, window), d = i(u ? "touchmove" : "mousemove", h, o, window)
            }, o)
          }

          function s(e, t) {
            for (var r in t) void 0 === e[r] && (e[r] = t[r]);
            return e
          }

          function l() {
            return +new Date
          }

          function c(e, t, r, n) {
            return (e - r) * (e - r) + (t - n) * (t - n)
          }
          t = s(t || {}, pointer.DEFAULTS);
          var u = function() {
            try {
            return document.createEvent("TouchEvent"), !0
          } catch (e) {
            return !1
          }
        }();
        return {
          on: function(t, r, s) {
            switch (s = s || e, t) {
                case "tap":
                case "singletap":
                case "hold":
                    a(t, n(r), s);
                    break;
                case "doubletap":
                    i("dblclick", n(r), s);
                    break;
                case "drag":
                case "dragend":
                case "dragstart":
                    o(t, r, s);
                    break;
                case "touch":
                    i(u ? "touchstart" : "mousedown", n(r), s);
                    break;
                case "move":
                    i(u ? "touchmove" : "mousemove", n(r), s);
                    break;
                case "release":
                    i(u ? "touchend" : "mouseup", n(r), s);
                    break;
                case "enter":
                    i(u ? "touchenter" : "mouseover", n(r), s);
                    break;
                case "leave":
                    i(u ? "touchleave" : "mouseout", n(r), s)
            }
            return this
          }
        }
      }

      function setOrientationControls(e) {
        if (!e.alpha) {
          return;
        }

        controls = new THREE.DeviceOrientationControls(camera, true);
        controls.connect();
        controls.update();

        element.addEventListener('click', fullscreen, false);

        window.removeEventListener('deviceorientation', setOrientationControls, true);
      }
      window.addEventListener('deviceorientation', setOrientationControls, true);


      var light = new THREE.HemisphereLight(0x777777, 0x000000, 0.6);
      scene.add(light);

      var texture = THREE.ImageUtils.loadTexture(
        'textures/patterns/checker.png'
      );
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      texture.repeat = new THREE.Vector2(50, 50);
      texture.anisotropy = renderer.getMaxAnisotropy();

      var material = new THREE.MeshPhongMaterial({
        color: 0xffffff,
        specular: 0xffffff,
        shininess: 20,
        shading: THREE.FlatShading,
        map: texture
      });

      var geometry = new THREE.PlaneGeometry(1000, 1000);

      var mesh = new THREE.Mesh(geometry, material);
      mesh.rotation.x = -Math.PI / 2;
      scene.add(mesh);

      window.addEventListener('resize', resize, false);
      setTimeout(resize, 1);

      function initPanoMapoteng() {
        // Note: constructed panorama objects have visible: true
        // set by default.
        var panoramaMapoteng = new google.maps.StreetViewPanorama(
          document.getElementById('map'), {
        position: { lat: -29.1141417, lng: 27.9686449},
        addressControlOptions: {
          position: google.maps.ControlPosition.BOTTOM_CENTER
        },
        linksControl: false,
        panControl: false,
        enableCloseButton: false
        });
      }


      //Map of South Africa Image
      var mapImage = document.createElement('img');
      mapImage.src = "resources/SouthAfricaPicture.PNG";

      //Placement and Fabrication of South Africa Image
      var mapTexture = new THREE.Texture( mapImage );
      mapTexture.needsUdate = true;
      mapMaterial = new THREE.MeshBasicMaterial({ map: mapTexture});
      mapGeometry = new THREE.PlaneGeometry(1404,870,1,2);
      mapMesh = new THREE.Mesh(mapGeometry, mapMaterial);
      mapMesh.position.set(0,100,0);
      scene.add(mapMesh);

      mapImage.addEventListener('click', initPanoMapoteng, false);
    }

    function resize() {
      var width = container.offsetWidth;
      var height = container.offsetHeight;

      camera.aspect = width / height;
      camera.updateProjectionMatrix();

      renderer.setSize(width, height);
      effect.setSize(width, height);
    }

    function update(dt) {
      resize();

      camera.updateProjectionMatrix();

      controls.update(dt);
    }

    function render(dt) {
      effect.render(scene, camera);
    }

    function animate(t) {
      requestAnimationFrame(animate);

      update(clock.getDelta());
      render(clock.getDelta());
    }

    function fullscreen() {
      if (container.requestFullscreen) {
        container.requestFullscreen();
      } else if (container.msRequestFullscreen) {
        container.msRequestFullscreen();
      } else if (container.mozRequestFullScreen) {
        container.mozRequestFullScreen();
      } else if (container.webkitRequestFullscreen) {
        container.webkitRequestFullscreen();
      }
    }
  </script>
  </body>
</html>
