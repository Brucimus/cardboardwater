<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Worldvision Clean Water Project</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        margin: 0px;
        overflow: hidden;
      }
      #webglviewer {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
      }
    </style>
  </head>
  <body>
    <div id="webglviewer"></div>

  <script src="js/third-party/threejs/three.js"></script>
  <script src="js/third-party/threejs/StereoEffect.js"></script>
  <script src="js/third-party/threejs/DeviceOrientationControls.js"></script>
  <script src="js/third-party/threejs/OrbitControls.js"></script>

  <script>
    var camera, scene, renderer;
    var effect, controls;
    var element, container;

    var clock = new THREE.Clock();

    init();
    animate();

    function init() {
      renderer = new THREE.WebGLRenderer();
      element = renderer.domElement;
      container = document.getElementById('webglviewer');
      container.appendChild(element);

      effect = new THREE.StereoEffect(renderer);

      scene = new THREE.Scene();

      camera = new THREE.PerspectiveCamera(90, 1, 0.001, 700);
      camera.position.set(0, 10, 0);
      scene.add(camera);

      controls = new THREE.OrbitControls(camera, element);
      controls.rotateUp(Math.PI / 4);
      controls.target.set(
        camera.position.x + 0.1,
        camera.position.y,
        camera.position.z
      );
      controls.noZoom = true;
      controls.noPan = true;

      //Pointer Icon
      function pointer(e, t) {
        function r(e) {
        e.touches ? (0 == e.touches.length ? (e.x = 0, e.y = 0) : (e.x = e.touches[0].clientX, e.y = e.touches[0].clientY), e.button = 0) : (e.x = e.clientX, e.y = e.clientY)
        }

        function n(t) {
        return function(n) {
            var i = e.getBoundingClientRect();
            r(n), n.localX = n.x - i.left, n.localY = n.y - i.top, t(n)
          }
        }

        function i(t, r, n, i) {
        return i = i || e, i.addEventListener(t, r, !1),
            function() {
                i.removeEventListener(t, r, !1)
            }
          }

          function o(t, n, o) {
          function a(e) {
            r(e), "dragend" == t && n.call(this, e), f(), d()
            }
            var s, l, c, h, f, d, p, m;
              i(u ? "touchstart" : "mousedown", function(g) {
                return r(g), m = e.getBoundingClientRect(), g.preventDefault(), g.stopPropagation(), c = s = g.x, h = l = g.y, p = !1, f = i(u ? "touchmove" : "mousemove", function(e) {
                r(e), e.localX = e.x - m.left, e.localY = e.y - m.top, e.movementX = e.x - s, e.movementY = e.y - l, e.deltaX = e.x - c, e.deltaY = e.y - h, e.px = s, e.py = l, s = e.x, l = e.y, p || (p = !0, "dragstart" == t && n.call(this, e)), "drag" == t && n.call(this, e)
                }, o, window), d = i(u ? "touchend" : "mouseup", a, o, window), !1
              })
            }

          function a(e, n, o) {
            function a() {
            clearTimeout(v), f && f(), d && d()
            }

            function s(r) {
            "tap" == e && l() - g < t.holdDuration && n.call(this, r), a()
          }

          function h(e) {
            r(e), c(e.x, e.y, p, m) > t.tapMoveThreshold && a()
          }
          var f, d, p, m, g, v;
            a(), i(u ? "touchstart" : "mousedown", function(a) {
            r(a), g = Date.now(), p = a.x, m = a.y, "hold" == e && (v = setTimeout(function() {
                n.call(o, a)
            }, t.holdDuration)), f = i(u ? "touchend" : "mouseup", s, o, window), d = i(u ? "touchmove" : "mousemove", h, o, window)
            }, o)
          }

          function s(e, t) {
            for (var r in t) void 0 === e[r] && (e[r] = t[r]);
            return e
          }

          function l() {
            return +new Date
          }

          function c(e, t, r, n) {
            return (e - r) * (e - r) + (t - n) * (t - n)
          }
          t = s(t || {}, pointer.DEFAULTS);
          var u = function() {
            try {
            return document.createEvent("TouchEvent"), !0
          } catch (e) {
            return !1
          }
        }();
        return {
          on: function(t, r, s) {
            switch (s = s || e, t) {
                case "tap":
                case "singletap":
                case "hold":
                    a(t, n(r), s);
                    break;
                case "doubletap":
                    i("dblclick", n(r), s);
                    break;
                case "drag":
                case "dragend":
                case "dragstart":
                    o(t, r, s);
                    break;
                case "touch":
                    i(u ? "touchstart" : "mousedown", n(r), s);
                    break;
                case "move":
                    i(u ? "touchmove" : "mousemove", n(r), s);
                    break;
                case "release":
                    i(u ? "touchend" : "mouseup", n(r), s);
                    break;
                case "enter":
                    i(u ? "touchenter" : "mouseover", n(r), s);
                    break;
                case "leave":
                    i(u ? "touchleave" : "mouseout", n(r), s)
            }
            return this
          }
        }
      }

      //Pointer Click Function
       Stereoscope = function(e) {
        function t(t, r, n, i) {
            var o, a, s, l;
            this.options = {
                backgroundColor: 2566178,
                slideDuration: 5e3,
                transitionDuration: 500
            };
            for (o in i) this.options[o] = i[o];
            for (a = new e.WebGLRenderer({
                    canvas: t
                }), a.setClearColor(this.options.backgroundColor), this.renderer = a, this.click = n, s = new e.Scene, this.scene = s, l = new e.OrthographicCamera(-.5, .5, -.5, .5, 0, 10), l.position.z = 1, this.camera = l, this.slides = [], this.currentSlide = -1, o = 0; o < r.length; o++) this._addSlide(r[o])
        }

        function r(e) {
            return new Promise(function(t, r) {
                var n = new Image;
                n.onload = function() {
                    t(n)
                }, n.onerror = function() {
                    r("failed to load " + e)
                }, n.src = e
            })
        }

        function n(e, t, r, n, i, o) {
            return void 0 === o && (o = 1.70158), (t /= i / 2) < 1 ? n / 2 * t * t * (((o *= 1.525) + 1) * t - o) + r : n / 2 * ((t -= 2) * t * (((o *= 1.525) + 1) * t + o) + 2) + r
        }
        var i = "audio/click.mp3",
            o = ["images/reel/0.jpg", "images/reel/1.jpg", "images/reel/2.jpg", "images/reel/3.jpg", "images/reel/4.jpg", "images/reel/5.jpg", "images/reel/6.jpg", "images/reel/7.jpg"];
        return t.create = function(e, n) {
            for (var a = AudioPlayer.create(n, i), s = [], l = 0; l < o.length; l++) s.push(r(o[l]));
            var c = Promise.all(s);
            return Promise.all([a, c]).then(function(r) {
                var n = r[0],
                    i = r[1];
                return new t(e.canvas, i, n)
            })
        }, t.prototype.enter = function() {}, t.prototype.leave = function() {}, t.prototype.render = function(e) {
            this._update(e), this.renderer.setClearColor(this.options.backgroundColor), this.renderer.clear(), this.renderer.render(this.scene, this.camera)
        }, t.prototype.resize = function(e, t, r) {
            r && (this.renderer.devicePixelRatio = r), this.renderer.setSize(e, t), this.camera.top = t / e / 2, this.camera.bottom = -t / e / 2, this.camera.updateProjectionMatrix()
        }, t.prototype._addSlide = function(t) {
            var r = new e.Texture(t);
            r.needsUpdate = !0;
            var n = new e.SpriteMaterial({
                    map: r,
                    color: 16777215
                }),
                i = new e.Sprite(n);
            i.scale.set(1, t.height / t.width, 1), this.scene.add(i), this.slides.push(i), i.visible = !1
        }, t.prototype._cameraPosition = function(e) {
            var t = Math.floor(e / this._period()),
                r = e % this._period(),
                i = 0;
            if (r > this.options.slideDuration) {
                var o = (r - this.options.slideDuration) / this.options.transitionDuration;
                i = n(void 0, o, 0, 1, 1, 1)
            }
            return t + i
        }, t.prototype._period = function() {
            return this.options.slideDuration + this.options.transitionDuration
        }, t.prototype._positionVisibleSlides = function(e) {
            for (var t = Math.floor(e - .5), r = Math.ceil(e + .5), n = this.slides.length, i = t; r >= i; i++) {
                var o = (i + n) % n,
                    a = Math.floor(i / n),
                    s = this.slides[o];
                s.visible = !0;
                var l = o;
                l += a * n, s.position.y = l
            }
        }, t.prototype._update = function(e) {
            var t = this.currentSlide,
                r = this._cameraPosition(e);
            this.currentSlide = Math.ceil(r - .5), this._positionVisibleSlides(r), this.camera.position.y = r, this.currentSlide > t && this.click.play()
        }, t
    }(THREE);
Demos.register({
    factory: Stereoscope.create,
    slug: "reel",
    preview: "/images/preview/reel.jpg"

      function setOrientationControls(e) {
        if (!e.alpha) {
          return;
        }

        controls = new THREE.DeviceOrientationControls(camera, true);
        controls.connect();
        controls.update();

        element.addEventListener('click', fullscreen, false);

        window.removeEventListener('deviceorientation', setOrientationControls, true);
      }
      window.addEventListener('deviceorientation', setOrientationControls, true);


      var light = new THREE.HemisphereLight(0x777777, 0x000000, 0.6);
      scene.add(light);

      var texture = THREE.ImageUtils.loadTexture(
        'textures/patterns/checker.png'
      );
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      texture.repeat = new THREE.Vector2(50, 50);
      texture.anisotropy = renderer.getMaxAnisotropy();

      var material = new THREE.MeshPhongMaterial({
        color: 0xffffff,
        specular: 0xffffff,
        shininess: 20,
        shading: THREE.FlatShading,
        map: texture
      });

      var geometry = new THREE.PlaneGeometry(1000, 1000);

      var mesh = new THREE.Mesh(geometry, material);
      mesh.rotation.x = -Math.PI / 2;
      scene.add(mesh);

      window.addEventListener('resize', resize, false);
      setTimeout(resize, 1);

      function initPanoMapoteng() {
        // Note: constructed panorama objects have visible: true
        // set by default.
        var panoramaMapoteng = new google.maps.StreetViewPanorama(
          document.getElementById('map'), {
        position: { lat: -29.1141417, lng: 27.9686449},
        addressControlOptions: {
          position: google.maps.ControlPosition.BOTTOM_CENTER
        },
        linksControl: false,
        panControl: false,
        enableCloseButton: false
        });
      }


      //Map of South Africa Image
      var mapImage = document.createElement('img');
      mapImage.src = "resources/SouthAfricaPicture.jpg";

      //Placement and Fabrication of South Africa Image
      var mapTexture = new THREE.Texture( mapImage );
      mapTexture.needsUdate = true;
      mapMaterial = new THREE.MeshBasicMaterial({ map: mapTexture});
      mapGeometry = new THREE.PlaneGeometry(1407,847,1,2);
      mapMesh = new THREE.Mesh(mapGeometry, mapMaterial);
      mapMesh.position.set(0,100,0);
      scene.add(mapMesh);

      mapImage.addEventListener('click', initPanoMapoteng, false);
    }

    function resize() {
      var width = container.offsetWidth;
      var height = container.offsetHeight;

      camera.aspect = width / height;
      camera.updateProjectionMatrix();

      renderer.setSize(width, height);
      effect.setSize(width, height);
    }

    function update(dt) {
      resize();

      camera.updateProjectionMatrix();

      controls.update(dt);
    }

    function render(dt) {
      effect.render(scene, camera);
    }

    function animate(t) {
      requestAnimationFrame(animate);

      update(clock.getDelta());
      render(clock.getDelta());
    }

    function fullscreen() {
      if (container.requestFullscreen) {
        container.requestFullscreen();
      } else if (container.msRequestFullscreen) {
        container.msRequestFullscreen();
      } else if (container.mozRequestFullScreen) {
        container.mozRequestFullScreen();
      } else if (container.webkitRequestFullscreen) {
        container.webkitRequestFullscreen();
      }
    }
  </script>
  </body>
</html>
